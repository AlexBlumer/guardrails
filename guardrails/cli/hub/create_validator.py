import os
from datetime import date
from string import Template

import typer
from pydash import pascal_case, snake_case

from guardrails.cli.hub.hub import hub
from guardrails.cli.logger import LEVELS, logger

validator_template = Template(
    """from typing import Any, Callable, Dict, Optional

from guardrails.validator_base import (
    FailResult,
    PassResult,
    ValidationResult,
    Validator,
    register_validator,
)


@register_validator(name="guardrails/${package_name}", data_type="string")
class ${class_name}(Validator):
    \"""# Overview

    | Developed by | {Your organization name} |
    | Date of development | ${dev_date} |
    | Validator type | Format |
    | Blog |  |
    | License | Apache 2 |
    | Input/Output | Output |

    # Description
    
    ## Intended Use
    This validator ensures that {write out your validators purpose here}.

    ## Requirements

    * Dependencies:
        - guardrails-ai>=0.4.0

    * Dev Dependencies:
        - pytest
        - pyright
        - ruff

    * Foundation model access keys:
        - {Include any access environment variables you need here like OPENAI_API_KEY}


    # Installation

    ```bash
    $ guardrails hub install hub://guardrails/${package_name}
    ```

    # Usage Examples

    ## Validating string output via Python

    In this example, we apply the validator to a string output generated by an LLM.

    ```python
    # Import Guard and Validator
    from guardrails.hub import ${class_name}
    from guardrails import Guard

    # Setup Guard
    guard = Guard.use(
        ${class_name}({list any args here})
    )

    guard.validate("pass")  # Validator passes
    guard.validate("fail")  # Validator fails
    ```

    ## Validating JSON output via Python

    In this example, we apply the validator to a string field of a JSON output generated by an LLM.

    ```python
    # Import Guard and Validator
    from pydantic import BaseModel
    from guardrails.hub import ${class_name}
    from guardrails import Guard

    val = ${class_name}({list any args here})

    # Create Pydantic BaseModel
    # Update or replace this model to match your use case.
    class Process(BaseModel):
    		process_name: str
    		status: str = Field(validators=[val])

    # Create a Guard to check for valid Pydantic output
    guard = Guard.from_pydantic(output_class=Process)

    # Run LLM output generating JSON through guard
    guard.parse(\"""
    {
    		"process_name": "templating",
    		"status": "pass"
    }
    \""")
    ```

    # API Reference

    **`__init__(self, on_fail="noop")`**
    <ul>
    Initializes a new instance of the ValidatorTemplate class.

    **Parameters**
    - **`arg_1`** *(str)*: A placeholder argument to demonstrate how to use init arguments.
    - **`arg_2`** *(str)*: Another placeholder argument to demonstrate how to use init arguments.
    - **`on_fail`** *(str, Callable)*: The policy to enact when a validator fails.  If `str`, must be one of `reask`, `fix`, `filter`, `refrain`, `noop`, `exception` or `fix_reask`. Otherwise, must be a function that is called when the validator fails.
    </ul>
    <br/>

    **`validate(self, value, metadata) â†’ ValidationResult`**
    <ul>
    Validates the given `value` using the rules defined in this validator, relying on the `metadata` provided to customize the validation process. This method is automatically invoked by `guard.parse(...)`, ensuring the validation logic is applied to the input data.

    Note:

    1. This method should not be called directly by the user. Instead, invoke `guard.parse(...)` where this method will be called internally for each associated Validator.
    2. When invoking `guard.parse(...)`, ensure to pass the appropriate `metadata` dictionary that includes keys and values required by this validator. If `guard` is associated with multiple validators, combine all necessary metadata into a single dictionary.

    **Parameters**
    - **`value`** *(Any):* The input value to validate.
    - **`metadata`** *(dict):* A dictionary containing metadata required for validation. Keys and values must match the expectations of this validator.
        
        
        | Key | Type | Description | Default |
        | --- | --- | --- | --- |
        | key1 | String | Description of key1's role. | N/A |
    </ul>
    \"""  # noqa

    # If you don't have any init args, you can omit the __init__ method.
    def __init__(
        self,
        arg_1: str,
        arg_2: str,
        on_fail: Optional[Callable] = None,
    ):
        super().__init__(on_fail=on_fail, arg_1=arg_1, arg_2=arg_2)
        self._arg_1 = arg_1
        self._arg_2 = arg_2

    def validate(self, value: Any, metadata: Dict) -> ValidationResult:
        \"""Validates that {fill in how you validator interacts with the passed value}.\"""
        # Add your custom validator logic here and return a PassResult or FailResult accordingly.
        if value != "pass": # FIXME
            return FailResult(
                error_message="{A descriptive but concise error message about why validation failed}",
                fix_value="{The programmtic fix if applicable, otherwise remove this kwarg.}",
            )
        return PassResult()


# Run tests via `pytest -rP ${filepath}`
class Test${class_name}:
    def test_success_case(self):
        validator = ${class_name}("s")
        result = validator.validate("pass", {})
        assert isinstance(result, PassResult) is True

    def test_failure_case(self):
        validator = ${class_name}("s")
        result = validator.validate("fail", {})
        assert isinstance(result, FailResult) is True
        assert result.error_message == "{A descriptive but concise error message about why validation failed}"
        assert result.fix_value == "fails"
"""
)


@hub.command(name="create-validator")
def create_validator(
    name: str = typer.Argument(help="The name for your validator."),
    filepath: str = typer.Argument(
        help="The location to write your validator template to",
        default="./{validator_name}.py",
    ),
):
    package_name = snake_case(name)
    class_name = pascal_case(name)
    if not filepath or filepath == "./{validator_name}.py":
        filepath = f"./{package_name}.py"

    template = validator_template.safe_substitute(
        {
            "package_name": package_name,
            "class_name": class_name,
            "filepath": filepath,
            "dev_date": date.today().strftime("%b %d, %Y"),
        }
    )

    target = os.path.abspath(filepath)
    with open(target, "w") as validator_file:
        validator_file.write(template)
        validator_file.close()

    success_message = Template(
        """

    Successfully created validator template at ${filepath}!

    Make any necessary changes then submit for review with the following command:

    guardrails hub submit ${package_name} ${filepath}
    """
    ).safe_substitute({"filepath": filepath, "package_name": package_name})
    logger.log(level=LEVELS.get("SUCCESS"), msg=success_message)  # type: ignore
